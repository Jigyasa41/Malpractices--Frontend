{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Jigyasa\\\\exam-proctor-frontend\\\\src\\\\VideoProctor.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef, useState } from 'react';\n\n// const VideoProctor = () => {\n//   const videoRef = useRef(null);\n//   const canvasRef = useRef(null);\n//   const [cheatingLog, setCheatingLog] = useState([]);\n\n//   useEffect(() => {\n//     let stream;\n\n//     // Start webcam\n//     navigator.mediaDevices.getUserMedia({ video: true })\n//       .then((mediaStream) => {\n//         stream = mediaStream;\n//         videoRef.current.srcObject = stream;\n//       })\n//       .catch((err) => console.error(\"❌ Error accessing webcam:\", err));\n\n//     // Send frame every 2 seconds\n//     const interval = setInterval(() => {\n//       sendFrameToBackend();\n//     }, 2000);\n\n//     return () => {\n//       clearInterval(interval);\n//       if (stream) {\n//         stream.getTracks().forEach(track => track.stop());\n//       }\n//     };\n//   }, []);\n\n//   const sendFrameToBackend = () => {\n//     const canvas = canvasRef.current;\n//     const video = videoRef.current;\n\n//     if (!canvas || !video || video.readyState !== 4) return;\n\n//     const context = canvas.getContext('2d');\n//     canvas.width = video.videoWidth;\n//     canvas.height = video.videoHeight;\n//     context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n//     canvas.toBlob(blob => {\n//       if (!blob) return;\n\n//       const formData = new FormData();\n//       formData.append('image', blob, 'frame.jpg');\n\n//       fetch('http://localhost:5000/detect-frame', {\n//         method: 'POST',\n//         body: formData,\n//       })\n//         .then(res => res.json())\n//         .then(data => {\n//           console.log('📸 Cheating Result:', data);\n//           if (data.cheating_detected) {\n//             setCheatingLog(prev => [\n//               ...prev,\n//               {\n//                 time: new Date().toLocaleTimeString(),\n//                 face_count: data.face_count,\n//                 mobile_detected: data.mobile_detected,\n//                 head_direction: data.head_direction,\n//               },\n//             ]);\n//           }\n//         })\n//         .catch(err => {\n//           console.error(\"❌ Error sending frame:\", err);\n//         });\n//     }, 'image/jpeg');\n//   };\n\n//   return (\n//     <div>\n//       <h3>🎥 Real-Time Proctoring Active</h3>\n//       <video ref={videoRef} autoPlay playsInline width={640} height={480} />\n//       <canvas ref={canvasRef} style={{ display: 'none' }} />\n\n//       {cheatingLog.length > 0 && (\n//         <div style={{ marginTop: \"20px\", textAlign: \"left\" }}>\n//           <h4>🚨 Cheating Instances</h4>\n//           <ul>\n//             {cheatingLog.map((log, idx) => (\n//               <li key={idx}>\n//                 🕒 {log.time} - Faces: {log.face_count}, Phone: {log.mobile_detected ? \"Yes\" : \"No\"}, Head: {log.head_direction}\n//               </li>\n//             ))}\n//           </ul>\n//         </div>\n//       )}\n//     </div>\n//   );\n// };\n\n// export default VideoProctor;\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoProctor = () => {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const interval = setInterval(() => {\n      sendFrameToBackend();\n    }, 2000);\n    navigator.mediaDevices.getUserMedia({\n      video: true\n    }).then(stream => {\n      videoRef.current.srcObject = stream;\n    });\n    return () => clearInterval(interval);\n  }, []);\n  const sendFrameToBackend = () => {\n    const canvas = canvasRef.current;\n    const video = videoRef.current;\n    const context = canvas.getContext(\"2d\");\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    context.drawImage(video, 0, 0, canvas.width, canvas.height);\n    canvas.toBlob(blob => {\n      const formData = new FormData();\n      formData.append(\"image\", blob, \"frame.jpg\");\n      fetch(\"http://localhost:5000/detect-frame\", {\n        method: \"POST\",\n        body: formData\n      }).then(res => res.json()).then(data => {\n        console.log(\"📡 Cheating result:\", data);\n      });\n    }, \"image/jpeg\");\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      width: 640,\n      height: 480\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 158,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        display: \"none\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 157,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoProctor, \"0gwqVvoOV2or9Ql4L8GH2BGn3hc=\");\n_c = VideoProctor;\nexport default VideoProctor; // ✅ THIS LINE IS CRITICAL\nvar _c;\n$RefreshReg$(_c, \"VideoProctor\");","map":{"version":3,"names":["React","useEffect","useRef","useState","jsxDEV","_jsxDEV","VideoProctor","_s","videoRef","canvasRef","interval","setInterval","sendFrameToBackend","navigator","mediaDevices","getUserMedia","video","then","stream","current","srcObject","clearInterval","canvas","context","getContext","width","videoWidth","height","videoHeight","drawImage","toBlob","blob","formData","FormData","append","fetch","method","body","res","json","data","console","log","children","ref","autoPlay","playsInline","fileName","_jsxFileName","lineNumber","columnNumber","style","display","_c","$RefreshReg$"],"sources":["C:/Users/Jigyasa/exam-proctor-frontend/src/VideoProctor.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from 'react';\r\n\r\n// const VideoProctor = () => {\r\n//   const videoRef = useRef(null);\r\n//   const canvasRef = useRef(null);\r\n//   const [cheatingLog, setCheatingLog] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     let stream;\r\n\r\n//     // Start webcam\r\n//     navigator.mediaDevices.getUserMedia({ video: true })\r\n//       .then((mediaStream) => {\r\n//         stream = mediaStream;\r\n//         videoRef.current.srcObject = stream;\r\n//       })\r\n//       .catch((err) => console.error(\"❌ Error accessing webcam:\", err));\r\n\r\n//     // Send frame every 2 seconds\r\n//     const interval = setInterval(() => {\r\n//       sendFrameToBackend();\r\n//     }, 2000);\r\n\r\n//     return () => {\r\n//       clearInterval(interval);\r\n//       if (stream) {\r\n//         stream.getTracks().forEach(track => track.stop());\r\n//       }\r\n//     };\r\n//   }, []);\r\n\r\n//   const sendFrameToBackend = () => {\r\n//     const canvas = canvasRef.current;\r\n//     const video = videoRef.current;\r\n\r\n//     if (!canvas || !video || video.readyState !== 4) return;\r\n\r\n//     const context = canvas.getContext('2d');\r\n//     canvas.width = video.videoWidth;\r\n//     canvas.height = video.videoHeight;\r\n//     context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n//     canvas.toBlob(blob => {\r\n//       if (!blob) return;\r\n\r\n//       const formData = new FormData();\r\n//       formData.append('image', blob, 'frame.jpg');\r\n\r\n//       fetch('http://localhost:5000/detect-frame', {\r\n//         method: 'POST',\r\n//         body: formData,\r\n//       })\r\n//         .then(res => res.json())\r\n//         .then(data => {\r\n//           console.log('📸 Cheating Result:', data);\r\n//           if (data.cheating_detected) {\r\n//             setCheatingLog(prev => [\r\n//               ...prev,\r\n//               {\r\n//                 time: new Date().toLocaleTimeString(),\r\n//                 face_count: data.face_count,\r\n//                 mobile_detected: data.mobile_detected,\r\n//                 head_direction: data.head_direction,\r\n//               },\r\n//             ]);\r\n//           }\r\n//         })\r\n//         .catch(err => {\r\n//           console.error(\"❌ Error sending frame:\", err);\r\n//         });\r\n//     }, 'image/jpeg');\r\n//   };\r\n\r\n//   return (\r\n//     <div>\r\n//       <h3>🎥 Real-Time Proctoring Active</h3>\r\n//       <video ref={videoRef} autoPlay playsInline width={640} height={480} />\r\n//       <canvas ref={canvasRef} style={{ display: 'none' }} />\r\n\r\n//       {cheatingLog.length > 0 && (\r\n//         <div style={{ marginTop: \"20px\", textAlign: \"left\" }}>\r\n//           <h4>🚨 Cheating Instances</h4>\r\n//           <ul>\r\n//             {cheatingLog.map((log, idx) => (\r\n//               <li key={idx}>\r\n//                 🕒 {log.time} - Faces: {log.face_count}, Phone: {log.mobile_detected ? \"Yes\" : \"No\"}, Head: {log.head_direction}\r\n//               </li>\r\n//             ))}\r\n//           </ul>\r\n//         </div>\r\n//       )}\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoProctor;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nimport React, { useEffect, useRef, useState } from 'react';\r\n\r\nconst VideoProctor = () => {\r\n  const videoRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    const interval = setInterval(() => {\r\n      sendFrameToBackend();\r\n    }, 2000);\r\n\r\n    navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {\r\n      videoRef.current.srcObject = stream;\r\n    });\r\n\r\n    return () => clearInterval(interval);\r\n  }, []);\r\n\r\n  const sendFrameToBackend = () => {\r\n    const canvas = canvasRef.current;\r\n    const video = videoRef.current;\r\n    const context = canvas.getContext(\"2d\");\r\n\r\n    canvas.width = video.videoWidth;\r\n    canvas.height = video.videoHeight;\r\n    context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n    canvas.toBlob(\r\n      (blob) => {\r\n        const formData = new FormData();\r\n        formData.append(\"image\", blob, \"frame.jpg\");\r\n\r\n        fetch(\"http://localhost:5000/detect-frame\", {\r\n          method: \"POST\",\r\n          body: formData,\r\n        })\r\n          .then((res) => res.json())\r\n          .then((data) => {\r\n            console.log(\"📡 Cheating result:\", data);\r\n          });\r\n      },\r\n      \"image/jpeg\"\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <video ref={videoRef} autoPlay playsInline width={640} height={480} />\r\n      <canvas ref={canvasRef} style={{ display: \"none\" }} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VideoProctor; // ✅ THIS LINE IS CRITICAL\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}